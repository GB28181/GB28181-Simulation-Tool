<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 8. Best Practices</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="SIP Servlets Server User Guide"/><link rel="up" href="index.html" title="SIP Servlets Server User Guide"/><link rel="prev" href="afotsss-Advanced_Features_of_the_SIP_Servlets_Server.html" title="Chapter 7. Advanced Features of the SIP Servlets Server"/><link rel="next" href="apa.html" title="Appendix A. Revision History"/></head><body><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="afotsss-Advanced_Features_of_the_SIP_Servlets_Server.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="apa.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="bp-Best_Practices"/>Chapter 8. Best Practices</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="bp-Best_Practices.html#bp-Best_Practices_Perf_Tips">8.1. Mobicents SIP Servlets Performance Tips</a></span></dt><dd><dl><dt><span class="section"><a href="bp-Best_Practices.html#d0e8316">8.1.1. Tuning JBoss</a></span></dt><dt><span class="section"><a href="bp-Best_Practices.html#d0e8331">8.1.2. Tuning Mobicents SIP Servlets</a></span></dt><dt><span class="section"><a href="bp-Best_Practices.html#d0e8359">8.1.3. Tuning The JAIN SIP Stack</a></span></dt><dt><span class="section"><a href="bp-Best_Practices.html#d0e8471">8.1.4. Tuning The JVM</a></span></dt><dt><span class="section"><a href="bp-Best_Practices.html#d0e8522">8.1.5. Tuning The Operating System</a></span></dt></dl></dd><dt><span class="section"><a href="bp-Best_Practices.html#bp-Best_Practices_NAT">8.2. NAT Traversal</a></span></dt><dd><dl><dt><span class="section"><a href="bp-Best_Practices.html#d0e8601">8.2.1. STUN</a></span></dt><dt><span class="section"><a href="bp-Best_Practices.html#d0e8610">8.2.2. TURN</a></span></dt><dt><span class="section"><a href="bp-Best_Practices.html#d0e8621">8.2.3. ICE</a></span></dt><dt><span class="section"><a href="bp-Best_Practices.html#d0e8636">8.2.4. Other Approaches</a></span></dt></dl></dd></dl></div><p>This chapter discusses Best Practices related to  Mobicents
  SIP Servlets usage in real world deployments.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="bp-Best_Practices_Perf_Tips"/>8.1. Mobicents SIP Servlets Performance Tips</h2></div></div></div><p>Because the default profile of Mobicents SIP Servlets  is targeted at a
    development environment,  some tuning is required to make the server performance  suitable for a  production environment.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8316"/>8.1.1. Tuning JBoss</h3></div></div></div><p>To ensure the server is finely tuned for a production envirionment, certain configuration must be changed.  Visit the   <a class="ulink" href="http://wiki.jboss.org/wiki/Wiki.jsp?page=JBossASTuningSliming">JBoss Application Server Tuning</a> wiki page to learn about optimization techniques.
       </p><p>While it is preferrable to have a fast Application Server,  most of the information doesn't apply to Mobicents.  In summary, the most important optimization technique is to remove logs, leaving only what is required.</p><p> Check the log configuration file in
      the following location and review the information.</p><p><code class="filename">$JBOSS_HOME/server/default/conf/jboss-log4j.xml</code></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8331"/>8.1.2. Tuning Mobicents SIP Servlets</h3></div></div></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Congestion Control</em></span> : It is recommended that this feature is enabled to avoid overload of the server and that the <span class="emphasis"><em>sipMessageQueueSize</em></span> and <span class="emphasis"><em>memoryThreshold</em></span> parameters are tuned according to <a class="xref" href="afotsss-Advanced_Features_of_the_SIP_Servlets_Server.html#sscacc-MSS_Concurrency_and_Congestion_Control" title="7.2. Concurrency and Congestion Control">Section 7.2, “Concurrency and Congestion Control”</a></p></li><li><p><span class="emphasis"><em>Concurrency</em></span> :
          <span class="emphasis"><em>Default Value : None.</em></span>  For better performance, it is recommended to leave  this value set to <strong class="userinput"><code>None</code></strong>.</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8359"/>8.1.3. Tuning The JAIN SIP Stack</h3></div></div></div><p>The stack can be fine-tuned by altering the SIP stack properties, defined in the external properties file specified by the <span class="emphasis"><em>sipStackPropertiesFile</em></span> attribute as described in <a class="xref" href="sssicar-SIP_Servlets_Server-Installing_Configuring_and_Running.html#bsssc-binary-SIP_Servlets_Server-Adding_SIP_Connectors" title="2.3.1. Configuring SIP Connectors">Section 2.3.1, “Configuring SIP Connectors”</a>.</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>gov.nist.javax.sip.THREAD_POOL_SIZE</em></span>
          </p><p><span class="emphasis"><em>Default value: 64</em></span> </p><p>This thread pool is
          responsible for parsing SIP messages received from socket messages into
          objects.  </p><p>A smaller value will make the stack less responsive, since
          new messages have to wait in a queue for free threads. In UDP, this
          can lead to more retransmissions. </p><p>Large thread pool sizes result in allocating resources
          that are otherwise not required.</p></li><li><p><span class="emphasis"><em>gov.nist.javax.sip.REENTRANT_LISTENER</em></span>
          </p><p><span class="emphasis"><em>Default value: true</em></span> </p><p>This flag indicates whether the
          SIP stack listener is executed by a single thread, or concurrently
          by the threads that parse the messages. </p><p>Mobicents SIP
          Servlets expects this flag to be set to <strong class="userinput"><code>true</code></strong>, therefore do not change the value.</p></li><li><p><span class="emphasis"><em>gov.nist.javax.sip.LOG_MESSAGE_CONTENT</em></span>
          </p><p><span class="emphasis"><em>Default value: true</em></span></p><p>Set the parameter to  <strong class="userinput"><code>false</code></strong> to disable message logging.</p></li><li><p><span class="emphasis"><em>gov.nist.javax.sip.TRACE_LEVEL=0</em></span>
          </p><p><span class="emphasis"><em>Default value: 32</em></span>. </p><p>Set the parameter to <strong class="userinput"><code>0</code></strong> to disable JAIN SIP stack logging.</p></li><li><p><span class="emphasis"><em>gov.nist.javax.sip.RECEIVE_UDP_BUFFER_SIZE=65536 and gov.nist.javax.sip.SEND_UDP_BUFFER_SIZE=65536</em></span>
          </p><p><span class="emphasis"><em>Default value: 65536</em></span>. </p><p>Those properties control the size of the UDP buffer used for SIP messages. Under load, if the buffer capacity is overflown the messages are dropped causing retransmissions, further increasing the load and causing even more retransmissions</p></li><li><p><span class="emphasis"><em>gov.nist.javax.sip.MAX_MESSAGE_SIZE=65536</em></span>
          </p><p><span class="emphasis"><em>Default value: 65536</em></span>. </p><p>This property control the maximum size of content that can be read for a SIP Message on UDP.  Default is 65536. The average UDP message size is quite lower than this so reducing this property will benefit memory usage since a byte buffer of this size is created for every message received</p><p>It also defines the maximum size of content that a TCP connection can read. Must be at least 4K. Default is "infinity" -- ie. no limit. This is to prevent DOS attacks launched by writing to a TCP connection until the server chokes.</p></li><li><p><span class="emphasis"><em>gov.nist.javax.sip.TCP_POST_PARSING_THREAD_POOL_SIZE=30</em></span>
          </p><p><span class="emphasis"><em>Default value: 30</em></span>. </p><p>Use 0 or do not set this option to disable it. When using TCP your phones/clients usually connect independently creating their own TCP sockets. Sometimes however SIP devices are allowed to tunnel multiple calls over a single socket. This can also be simulated with SIPP by running "sipp -t t1". In the stack each TCP socket has it's own thread. When all calls are using the same socket they all use a single thread, which leads to severe performance penalty, especially on multi-core machines. This option instructs the SIP stack to use a thread pool and split the CPU load between many threads. The number of the threads is specified in this parameter. The processing is split immediately after the parsing of the message. It cannot be split before the parsing because in TCP the SIP message size is in the Content-Length header of the message and the access to the TCP network stream has to be synchronized. Additionally in TCP the message size can be larger. This causes most of the parsing for all calls to occur in a single thread, which may have impact on the performance in trivial applications using a single socket for all calls. In most applications it doesn't have performance impact. If the phones/clients use separate TCP sockets for each call this option doesn't have much impact, except the slightly increased memory footprint caused by the thread pool. It is recommended to disable this option in this case by setting it 0 or not setting it at all. You can simulate multi-socket mode with "sipp -t t0". With this option also we avoid closing the TCP socket when something fails, because we must keep processing other messages for other calls. Note: This option relies on accurate Content-Length headers in the SIP messages. It cannot recover once a malformed message is processed, because the stream iterator will not be aligned any more. Eventually the connection will be closed.</p></li></ul></div><p>The full list of JAIN SIP stack properties is available from
      <a class="ulink" href="http://snad.ncsl.nist.gov/proj/iptel/jain-sip-1.2/javadoc/javax/sip/SipStack.html">the SIP Stack Properties Home Page</a>
      and the full list of implementation specific properties are available
      from the <a class="ulink" href="http://snad.ncsl.nist.gov/proj/iptel/jain-sip-1.2/javadoc/gov/nist/javax/sip/SipStackImpl.html">SIP Stack Implementation Home Page</a>.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8471"/>8.1.4. Tuning The JVM</h3></div></div></div><p>The following tuning information applies to Sun JDK 1.6, however  the information should also apply
      to Sun JDK 1.5.  </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>For more information on performance, refer to  the <a class="ulink" href="http://java.sun.com/performance/reference/whitepapers/6_performance.html">Performance White Paper</a>.</p></div><p>To pass arguments to the JVM, change
      <code class="filename">$JBOSS_HOME/bin/run.conf</code> (Linux) or <code class="filename">$JBOSS_HOME/bin/run.bat</code> (Windows).</p><div class="itemizedlist"><ul><li><p><span class="bold"><strong>Garbage Collection</strong></span> </p><p>JVM
          ergonomics automatically attempt to select the best garbage collector. The
          default behaviour is to select the throughput collector, however a disadvantage of the throughput collector is that it can have long pauses times, which
          ultimately blocks  JVM processing. </p><p>For low-load implementations, consider using  the incremental, low-pause, garbage collector
          (activated by specifying <span class="emphasis"><em>
              <strong class="userinput"><code>-XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode</code></strong>
            </em></span>). Many SIP applications can benefit from this garbage collector type because  it reduces the retransmission amount. </p><p>For more
          information please read: <a class="ulink" href="http://java.sun.com/javase/technologies/hotspot/gc/gc_tuning_6.html">Garbage Collector Tuning </a></p></li><li><p><span class="bold"><strong>Heap</strong></span> <span class="bold"><strong>Size</strong></span> </p><p>Heap size is an important consideration for
          garbage collection. Having an unnecessarily large heap can stop the JVM for
          seconds, to perform garbage collection. </p><p>Small heap sizes are not
          recommended either, because they put unnecessary pressure on the  garbage
          collection system.  </p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8522"/>8.1.5. Tuning The Operating System</h3></div></div></div><p>The following tuning information is provided for Red Hat Enterprise Linux (RHEL) servers that are running high-load configurations.   The tuning information  should also apply to other Linux distributions.</p><p>After you have configured RHEL with the tuning information, you must restart the operating system.   You should see improvements in I/O response times. With SIP, the
      performance improvement can be as high as  20%. </p><div class="itemizedlist"><ul><li><p><span class="bold"><strong>Large Memory Pages</strong></span> </p><p>Setting large memory pages
          can reduce CPU utilization by up to  5%. </p><p>Ensure that  the option
          <span class="emphasis"><em>
              <strong class="userinput"><code>-XX:+UseLargePages</code></strong>
            </em></span> is passed and ensure that the following Java
          HotSpot(TM) Server VM warning does not occur:</p><p><code class="literal">Failed to reserve shared memory (errno = 22)" when starting JBoss.</code> It means that the number of pages at OS level is still not enough.</p><p>To learn
          more about large memory pages, and how to configure them, refer to 
          <a class="ulink" href="http://java.sun.com/javase/technologies/hotspot/largememory.jsp">Java Support for Large Memory Pages</a> and <a class="ulink" href="http://andrigoss.blogspot.com/2008/02/jvm-performance-tuning.html">Andrig's Miller blog post</a>.</p></li><li><p><span class="emphasis"><em>Network buffers</em></span> </p><p>You can
          increase the network buffers size by adding the following lines to
          your <code class="filename">/etc/sysctl.conf</code> file:</p><div class="itemizedlist"><ul><li><p><strong class="userinput"><code>net.core.rmem_max = 16777216</code></strong></p></li><li><p><strong class="userinput"><code>net.core.wmem_max = 16777216</code></strong></p></li><li><p><strong class="userinput"><code>net.ipv4.tcp_rmem = 4096 87380 16777216</code></strong></p></li><li><p><strong class="userinput"><code>net.ipv4.tcp_wmem = 4096 65536 16777216</code></strong></p></li><li><p><strong class="userinput"><code>net.core.netdev_max_backlog = 300000</code></strong></p></li></ul></div></li><li><p>Execute the following command to set the network interface address:</p><p><code class="command">sudo ifconfig [eth0] txqueuelen 1000 # </code></p><p>Replace [eth0] with the correct name of the
          actual network interface you are setting up.</p></li></ul></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="bp-Best_Practices_NAT"/>8.2. NAT Traversal</h2></div></div></div><p>In a production environment,  it is common to see SIP and Media
    data passing through different kinds of Network Address Translation (NAT)  to reach the
    required endpoints. Because NAT Traversal is a complex topic, refer to the following information to help determine the most effective method to handle NAT issues.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8601"/>8.2.1. STUN</h3></div></div></div><p>STUN (Session Traversal Utilities for NAT) is not generally
      considered a viable solution for enterprises because STUN cannot be used
      with symmetric NATs. </p><p>Most enterprise-grade
      firewalls are symmetric, therefore STUN support must be provided  in the SIP Clients themselves.  
      </p><p>Most of the proxy and media gateways installed by VoIP providers 
      recognize the public IP address the packets have originated from.   When both SIP end points are behind a NAT, they can act as
      gateways to clients behind NAT.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8610"/>8.2.2. TURN</h3></div></div></div><p>TURN (Traversal Using Relay NAT) is an IETF standard, which
      implements media relays for SIP end-points. The standard overcomes the problems of
      clients behind symmetric NATs which cannot rely on STUN to solve NAT
      traversal. </p><p>TURN connects clients behind a NAT to a single peer, providing the same protection offered by symmetric NATs and
      firewalls. The TURN server acts as a relay; any data received is
      forwarded. </p><p>This type of implementation is not ideal. It assumes the clients
      have a trust relationship with a TURN server,  and a request session
      allocation based on shared credentials. </p><p>This can result in scalability issues,
      and requires changes in the SIP clients.  It is also impossible to determine
      when a direct, or TURN, connection is appropriate.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8621"/>8.2.3. ICE</h3></div></div></div><p>ICE (Interactive Connection Establishment) leverages both
      STUN and TURN to solve the NAT traversal issues.</p><p>It allows devices to
      probe for multiple paths of communication, by attempting to use different
      port numbers and STUN techniques. If ICE support is present in both
      devices, it is quite possible that the devices can initiate and maintain communication
      end-to-end, without any intermediary media relay.</p><p>Additionally, ICE can
      detect cases where direct communication is impossible and automatically initiate  fall-back to a media relay. </p><p>ICE is not currently in  widespread  use in SIP devices, because ICE capability must be embedded within 
      the SIP devices. </p><p>Depending
      on the negotiated connection, a  reINVITE may be required during a session, which adds more
      load to the SIP network and more latency to the call. </p><p>If the
      initiating ICE client attempts to call a non-ICE client, then the call
      setup-process will revert to a conventional SIP call requiring NAT
      traversal to be solved by other means.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8636"/>8.2.4. Other Approaches</h3></div></div></div><p>Other approaches include using proxy and media that can act as
      gateways, Session Border Controllers, enhanced Firewall with Application
      Layer Gateway (ALG) and Tunnelling.</p></div></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="afotsss-Advanced_Features_of_the_SIP_Servlets_Server.html"><strong>Prev</strong>Chapter 7. Advanced Features of the SIP Servlets ...</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="apa.html"><strong>Next</strong>Appendix A. Revision History</a></li></ul></body></html>